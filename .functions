# My custom shell functions, most of which should probably be scripts in a bin somewhere. A project for another day

function cd_atom {
  cd $1 && atom .
}

function cd_ll {
  cd $1 && k -Ah
}

function args_test {
  last=${@: -1}
  echo $@
  echo $last
  echo $#
}

function bundle_rails_server_on_port {
  if [ $1 ]; then
    bundle exec rails server -p $1
    return 0
  else
    echo "${RED}Error: Enter port number to run server on${NONE}"
    return 1
  fi
}

function cd_subl {
  cd $1 && subl .
}

function git_add_commit {
  if [ $2 ]; then
    g_add=$1
    g_msg=$2
  else
    return "Enter a commit message"
  fi
  git add $g_add
  git commit -m $g_msg
}

function git_add_commit_push {
  git_add_commit $1 $2
  g_branch=$(git rev-parse --symbolic-full-name --abbrev-ref HEAD)
  git push -u origin $g_branch
}

function git_branch_delete {
  case $1 in
  '-l')
    shift
    git_branch_delete_local "$@"
    ;;
  '-r')
    shift
    git_branch_delete_remote "$@"
    ;;
  '-lr'|'-rl')
    shift
    git_branch_delete_local_and_remotes "$@"
    ;;
  *)
    echo "Usage: $0: At least one flag is required:
    -l branch_name[s, ...]            # deletes local branch only
    -r [remote/]branch_name[s, ...]   # delete remote branch only
    -lr|-rl [remote/]branch_name[s, ...] # deletes local and remote branches
If no remote provided for -r|-lr|-rl, origin is assumed
"
    ;;
  esac
}

function git_branch_delete_local {
  local_branches=()
  for branch in $@
  do
    remote_and_or_branch=( $(echo $branch | tr "/" " ") )
    length=${#remote_and_or_branch}
    local_branches+=("${remote_and_or_branch[$length]}")
  done

  git branch -D $local_branches
}

function git_branch_delete_remote {
  for remote_branch in $@
  do
    remote_and_or_branch=( $(echo $remote_branch | tr "/" " ") )
    if [ ${#remote_and_or_branch} -eq 2 ]; then
      remote=${remote_and_or_branch[1]}
      branch=${remote_and_or_branch[2]}
    else
      remote='origin'
      branch="$remote_and_or_branch"
    fi
    git push $remote --delete $branch
  done
}

function git_branch_delete_local_and_remotes {
  if [ $# -lt 1 ]; then
    return "Usage: $0 [remote/]branch_name[s, ...]"
  fi

  git_branch_delete_local "$@"
  git_branch_delete_remote "$@"
}

function git_commit_push {
  git commit -m $1 && git push
}

function git_diff_file {
  if [ $3 ]; then
    commit2=$3
  else
    commit2="HEAD"
  fi

  if [ $2 ]; then
    file=$1
    commit1=$2
    git diff $commit1 $commit2 $file
  else
    echo "Usage: git_diff_file COMMIT FILE_NAME" >&2; return 1
  fi
}

function git_ignore_and_remove {
  echo $1 >> ./.gitignore; git rm --cached $1
}

function git_lastnhashes {
  git rev-list --max-count=$1 HEAD
}

function git_stash_apply_saved_stash {
  if [ ! -n $1 ]; then
    echo 'Must enter a stash name'
    return 1
  else
    git stash apply stash^{/"$1"}
    return 0
  fi
}

function mkdir_cd {
  if [ ! -n "$1" ]; then
    echo "Enter a directory name"
    return 1
  elif [ -d $1 ]; then
    echo "\`$1' already exists"
    return 2
  else
    mkdir $1 && cd $1
    return 0
  fi
}

function new_react_project {
  GRN='\033[0;32m'
  NONE='\033[0m'

  echo "${GRN}initialize directory${NONE}"
  mkcd $1 &&
  echo "${GRN}create package.json${NONE}"
  npm init --yes &&
  echo "${GRN}install react components${NONE}"
  react_install &&
  echo "${GRN}install webpack${NONE}"
  react_webpack &&
  echo "${GRN}install babel components${NONE}"
  react_babel_install &&
  echo "${GRN}create index.html${NONE}"
  touch index.html &&
  echo "${GRN}create lib/${NONE}"
  mkdir lib &&
  echo "${GRN}create lib/app.jsx${NONE}"
  touch lib/app.jsx &&
  echo "${GRN}initialize git repo${NONE}"
  git init &&
  gac . "initial commit" &&
  atom . &&
  wp --watch

}

function omni_killer {
  count=0
  pids="$(pids_for $1)"

  for pid in $(echo $pids); do
    (kill -9 $(($pid)) || kill -9 $pid) && ((count++))
  done

  if [ $count = 1 ]; then
    echo "1 $1 process terminated: $pids."
  elif [ $count -gt 0 ]; then
    echo "$count $1 processes terminated: $pids."
  else
    echo "No $1 processes found."
  fi
}

function over {
  cd ../$1
}

function pids_for {
  psaux_with_grep $1 |
  grep -v grep |
  awk '{print $2}' |
  tr '\n' ' ' |
  sed 's/[[:space:]]*$//'
}

function ping_google {
  if [ $1 ]; then
    count=$1
  else
    count=5
  fi

  ping -c $count google.com
}

function psaux_with_grep {
  ps aux |
  grep $1
}

function rails_new {
  rails _4.2.5.1_ new $1 --rc="~/.railsrc" --template="~/.railsrc"
}

function rails_server_on_port {
  if [ $1 ]
    rails server -p $1
    return 0
  then
    echo 'Error: Enter port number to run server on'
    return 1
  fi
}

function rails_reset {
  mysql.server restart &&
  bundle install &&
  rake db:drop &&
  rake db:create &&
  rake db:migrate &&
  rake db:seed &&
  rails server
}

function reload_redis {
  if [ $1 ]; then
    new_dump_file=$1
  else
    new_dump_file="sony.rdb"
  fi
  cp "$ANALYTICS_HOME/$new_dump_file" "$ANALYTICS_HOME/sawmill/dump.rdb"
}

function uninstallAllLocalGems {
  YLW='\033[1;33m'
  NONE='\033[0m'
  list=`gem list --no-versions`
  for gem in `echo $list`; do # `echo $list` part is for zsh; bash only needs $list
    if [[ $gem = bundler ]]; then echo -e "${YLW}Skipping $gem${NONE}"; continue; fi
    gem uninstall $gem -aIx
  done
  gem list
}

function untarAll {
  for file in $( ls ); do
    dir=${file%.tar};
    mkdir $dir;
    tar -C $dir/ -xvf $file;
  done
}

function untargzAll {
   for file in $( ls ); do
    dir=${file%.tar};
    mkdir $dir;
    tar -C $dir/ -zxvf $file;
  done
}

function which_cd {
  cd `which $1 | xargs dirname`
}

function which_cd_ll {
  cd `which $1 | xargs dirname` && k -Ah
}

function z_atom {
  z $1 && atom .
}

function z_ll {
  z $1 && k -Ah
}

echo 'Sourced .functions'
