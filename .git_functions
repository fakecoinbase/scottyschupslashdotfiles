function git_add_commit {
  if [ $2 ]; then
    g_add=$1
    g_msg=$2
  else
    return "Enter a commit message"
  fi
  git add $g_add
  git commit -m $g_msg
}

function git_add_commit_push {
  git_add_commit $1 $2
  g_branch=$(git rev-parse --symbolic-full-name --abbrev-ref HEAD)
  git push -u origin $g_branch
}

function git_branch_delete {
  case $1 in
  '-l')
    shift
    git_branch_delete_local "$@"
    ;;
  '-r')
    shift
    git_branch_delete_remote "$@"
    ;;
  '-lr'|'-rl')
    shift
    if test $# -eq 0; then
      git_branch_delete_usage
      return 2
    fi
    git_branch_delete_local_and_remote "$@"
    ;;
  *)
    git_branch_delete_usage
    return 1
    ;;
  esac
}

function git_branch_delete_usage {
  echo "Usage: git_branch_delete: At least one flag is required:
    -l branch_name[s, ...]               # deletes local branch only
    -r [remote/]branch_name[s, ...]      # delete remote branch only
    -lr|-rl [remote/]branch_name[s, ...] # deletes local and remote branches
If no remote provided for -r|-lr|-rl, origin is assumed
"
}

function git_branch_delete_local {
  branches=( $@ )
  local_branches=()
  for branch in $branches
  do
    remote_and_or_branch=( $(echo $branch | tr "/" " ") )
    length=${#remote_and_or_branch}
    local_branches+=("${remote_and_or_branch[$length]}")
  done

  echo "${YLW}Deleting local branch(es): $local_branches${NONE}"
  git_resp=$(git branch -D $local_branches)
  handle_git_resp "$git_resp"
}

function git_branch_delete_remote {
  for remote_branch in $@
  do
    local remote_and_or_branch=( $(echo "$remote_branch" | tr "/" " ") )

    if [ ${#remote_and_or_branch[@]} -eq 2 ]; then
      remote=${remote_and_or_branch[1]}
      branch=${remote_and_or_branch[2]}
    else
      echo 'Defaulting to remote => origin'
      remote='origin'
      branch="$remote_and_or_branch"
    fi

    git push $remote --delete $branch
    git remote prune origin
  done
}

function git_branch_delete_local_and_remote {
  if test $# -eq 0; then
    return "Usage: $0 [remote/]branch_name[s, ...]"
  fi

  git_branch_delete_local $@
  git_branch_delete_remote $@
  git remote prune origin
}

function git_commit_push {
  git commit -m $1 && git push
}


function git_diff_file {
  if [ $3 ]; then
    commit2=$3
  else
    commit2="HEAD"
  fi

  if [ $2 ]; then
    file=$1
    commit1=$2
    git diff $commit1 $commit2 $file
  else
    echo "Usage: git_diff_file COMMIT FILE_NAME" >&2; return 1
  fi
}

function git_checkout_safe_force {
  branch=$1
  g_status=${$(git status)[-1]}

  if [ "$g_status" != "clean" ]; then
    stash=1
    git stash
  fi

  git checkout $branch
  if [ $? -eq 1 ]; then
    git checkout -b $branch
  fi

  if [ $stash ]; then
    echo "$YLW\nWARNING:$NONE the following unstaged changes were stashed!"
    echo "`git stash show`"
  else
    echo $GRN"Success!"$NONE
  fi
}

function git_ignore_and_remove {
  for file in $@;
  do
    printf "\n$file" >> ./.gitignore;

    if [[ -f $file ]]; then
      git rm --cached $file;
    elif [[ -d $file ]]; then
      git rm -r --cached $file;
    fi
  done
  printf "\n" >> ./.gitignore;
}

function git_lastnhashes {
  git rev-list --max-count=$1 HEAD
}

function git_stash_apply_saved_stash {
  if [ ! -n $1 ]; then
    echo "Usage $0: Must enter a stash name"
  else
    git stash apply stash^{/"$1"}
  fi
}

function handle_git_resp {
  if [[ $line == "err*" ]]; then
    echo "${RED}$1${NONE}"
  else
    echo "${GRN}$1${NONE}"
  fi
}

function git_include_from_external_dir {
  remote_path=$1
  local_path=${2:-.}
  cp -r $remote_path $local_path && git status
}
alias gifed=git_include_from_external_dir

function was_successful {
  echo "***** FUNCTION: $0"
  if [ $# == 0 ]
  then
    return "Must pass in branches to check for"
  fi

  gfa
  check=()
  for branch_name in $1
  do
    check+=( $(gba | grep "$branch_name") )
  done
  if [ ${#check} == 0 ]
  then
    echo "\nSuccess!"
    return 0
  else
    echo "\nUh-oh! :("
    echo "\n$check"
    return 1
  fi
}

echo 'Sourced .git_functions'
